# React vs Java — key paradigm differences (high level)

| Aspect                            | React (JavaScript/TypeScript in the browser)                                                                                                                               | Java (typical backend / JVM apps)                                                                                                                                                                                    |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Blocking vs non-blocking**      | Mostly **non-blocking** by default in UI code: you avoid blocking the main thread, and rely on events + async APIs. Blocking the UI thread freezes the app.                | Often **blocking** by default in classic server code (e.g., one request handled by a thread doing blocking I/O). Non-blocking exists (e.g., reactive stacks) but is not the default mental model for many Java apps. |
| **Threads**                       | In the browser you generally have **1 main thread** for UI + JS. Heavy work is pushed to **Web Workers**; concurrency is mostly event-loop based rather than many threads. | **Multi-threading is a core feature**: threads, thread pools, synchronization primitives, etc. Servers commonly run many threads concurrently.                                                                       |
| **Async vs sync**                 | Async is very common and ergonomic: **Promises**, `async/await`, callbacks, event handlers. UI work is structured around asynchronous events.                              | Sync call stacks are very common in traditional Java. Async exists via **`CompletableFuture`**, reactive libraries, async servlets, etc., but many codebases remain primarily synchronous.                           |
| **Primary paradigm (COP vs OOP)** | React encourages **composition** (often called “component-oriented” or “composition over inheritance”). Functions + hooks are common; inheritance is rare.                 | Java is fundamentally **OOP**: classes, interfaces, encapsulation, inheritance (though composition is still best practice, the language centers around objects/classes).                                             |
| **Typical code style**            | Tends toward **concise expressions** and functional patterns (map/filter/reduce), lots of ES6+ features, inline lambdas, destructuring.                                    | Often **more verbose**, with explicit types, getters/setters, class structure, checked exceptions, etc. (Modern Java is less verbose than before, but still generally heavier than JS).                              |
| **“Multi-tech” surface area**     | Frontend work usually mixes **JS/TS + HTML (JSX) + CSS** (plus bundlers, tooling, browser APIs). React sits in a larger web stack.                                         | Often “mostly Java” for core logic (plus build tooling). UI is usually separate; backend apps are frequently Java-centric in day-to-day coding.                                                                      |
| **Scripting vs compiled**         | Usually treated as **scripting / interpreted at runtime** (even if it’s bundled/minified). TypeScript compiles to JS, but the runtime is still JavaScript.                 | **Compiled to bytecode** and run on the **JVM** (JIT compilation at runtime). Strong compile-time checking is a major part of the workflow.                                                                          |
| **Immutability vs mutability**    | React strongly *encourages* **immutable updates** (especially for state/props) because change detection and predictability are easier with immutability.                   | Java is often **mutable by default** (objects with setters, changing state). Immutability is possible and common in good design, but not “the default feeling” of many APIs.                                         |
| **Typing (not typed / typed)**    | JavaScript is **dynamically typed** (types enforced at runtime). In many React projects, **TypeScript** adds optional **static typing** at compile time.                   | **Statically typed** (types checked at compile time) and generally more strict/explicit.                                                                                                                             |

## Quick clarification

- **React** is a *UI library*, not a full language/runtime; many of these traits come from **JavaScript in the browser** + React’s conventions.
- **Java** is a *language + runtime* used in many paradigms; the “blocking/thread-per-request” description is most accurate for **traditional server-side Java** (not necessarily reactive Java).
